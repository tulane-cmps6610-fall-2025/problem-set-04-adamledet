# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gmNpTFYdongrdSyPA-NJnIBy2Keel-t1
"""

import math, queue
from collections import Counter

####### Problem 1 #######

class TreeNode(object):
    # we assume data is a tuple (frequency, character)
    def __init__(self, left=None, right=None, data=None):
        self.left = left
        self.right = right
        self.data = data
    def __lt__(self, other):
      #print(self.data)
      #print(other.data)
      return(self.data < other.data)
    def children(self):
        return((self.left, self.right))

def get_frequencies(fname):
    f=open(fname, 'r')
    C = Counter()
    for l in f.readlines():
        C.update(Counter(l))
    return(dict(C.most_common()))

# given a dictionary f mapping characters to frequencies,
# create a prefix code tree using Huffman's algorithm
def make_huffman_tree(f):
    p = queue.PriorityQueue()
    # construct heap from frequencies, the initial items should be
    # the leaves of the final tree
    for c in f.keys():
        p.put(TreeNode(None,None,(f[c], c)))

    # greedily remove the two nodes x and y with lowest frequency,
    # create a new node z with x and y as children,
    # insert z into the priority queue (using an empty character "")
    while (p.qsize() > 1):
      x = p.get()
      y = p.get()
      z = TreeNode(x,y,((x.data[0]+y.data[0]),""))
      p.put(z)

    # return root of the tree
    return p.get()

# perform a traversal on the prefix code tree to collect all encodings
def get_code(node, prefix="", code={}):
  # TODO - perform a tree traversal and collect encodings for leaves in code
  if(node.data[1]==""):
    left = get_code(node.left, prefix+"1", code)
    right = get_code(node.right, prefix+"0", code)
    return((left|right))# merge and return two 'code' dictionaries
  else:
    code[str(node.data[1])] = prefix
    return(code)

# given an alphabet and frequencies, compute the cost of a fixed length encoding
def fixed_length_cost(f):
    cost = math.ceil(math.log2(len(f)))#Length of the binary string for each character
    characters = sum(f.values())# Number of total characters
    return(cost*characters)

# given a Huffman encoding and character frequencies, compute cost of a Huffman encoding
def huffman_cost(C, f):
    cost = 0
    for entry in C:
      c = f[str(entry)] * len(C[str(entry)])
      cost += c
      #print(entry, ":",f[entry],"*",len(C[entry]),"=",c)#Output each cost entry
    return cost

fixedLenCosts = {}
huffmanCosts = {}

"""# f1.txt"""

f = get_frequencies('f1.txt')
fixedLenCosts["f1"] = fixed_length_cost(f)
print("Fixed-length cost:  %d" % fixedLenCosts["f1"])

T = make_huffman_tree(f)
C = get_code(T)
huffmanCosts["f1"] = huffman_cost(C, f)
print("Huffman cost:  %d" % huffmanCosts["f1"])

print(len(f))
print(len(C))

"""# alice29.txt"""

f = get_frequencies('alice29.txt')
fixedLenCosts["alice29"] = fixed_length_cost(f)
print("Fixed-length cost:  %d" % fixedLenCosts["alice29"])

T = make_huffman_tree(f)
C = get_code(T)
huffmanCosts["alice29"] = huffman_cost(C, f)
print("Huffman cost:  %d" % huffmanCosts["alice29"])
print(len(f))
print(len(C))

"""# asyoulik.txt"""

f = get_frequencies('asyoulik.txt')
fixedLenCosts["asyoulik"] = fixed_length_cost(f)
print("Fixed-length cost:  %d" % fixedLenCosts["asyoulik"])
T = make_huffman_tree(f)
C = get_code(T)
huffmanCosts["asyoulik"] = huffman_cost(C, f)
print("Huffman cost:  %d" % huffmanCosts["asyoulik"])
print(len(f))
print(len(C))

"""## fields.c"""

f = get_frequencies('fields.c')
fixedLenCosts["fields"] = fixed_length_cost(f)
print("Fixed-length cost:  %d" % fixedLenCosts["fields"])
T = make_huffman_tree(f)
C = get_code(T)
huffmanCosts["fields"] = huffman_cost(C, f)
print("Huffman cost:  %d" % huffmanCosts["fields"])
print(len(f))
print(len(C))

"""## grammar.lsp"""

f = get_frequencies('grammar.lsp')
fixedLenCosts["grammar"] = fixed_length_cost(f)
print("Fixed-length cost:  %d" % fixedLenCosts["grammar"])
T = make_huffman_tree(f)
C = get_code(T)
huffmanCosts["grammar"] = huffman_cost(C, f)
print("Huffman cost:  %d" % huffmanCosts["grammar"])
print(len(f))
print(len(C))

"""## Table"""

HuffToLen = {}
for c in fixedLenCosts.keys():
  HuffToLen[c] = huffmanCosts[c] / fixedLenCosts[c]

import pandas as pd
data = [
    fixedLenCosts,
    huffmanCosts,
    HuffToLen
]
df = pd.DataFrame(data)
df = df.T.rename(columns={0:"Fixed Length", 1:"Huffman Coding", 2:"Huffman:Length"})# Transpose and rename columns to get clean data
print(df)
# The Huffman coding trends better and better at each file

"""# Scratchwork"""

f = None
C = None
T = None
toyData = {
    "a":53,
    "b":53,
    "c":53,
    "d":53,
    "e":53,
    "f":53,
    "g":53,
    "h":53,
    "i":53,
    "j":53,
    "k":53,
    "l":53,
    "m":53,
    "n":53
}
toyData

costF = fixed_length_cost(toyData)
print("Fixed-length cost: ", costF)
T = make_huffman_tree(toyData)
C = get_code(T)
costH = huffman_cost(C, toyData)
print("Huffman cost: ", costH)
print(len(toyData))
print(len(C))

T.right.right.right.right.data

C

T.data

f

f = get_frequencies('f1.txt')
print("Fixed-length cost:  %d" % fixed_length_cost(f))

T = make_huffman_tree(f)

#Root data
T.data

#Example of navigating down path
T.right.left.left.left.left.right.data



T.children()

min(f,key=f.get)

f

t1 = {1: "one", 2: "two", 3: "three"}
t2 = {4: "four", 5: "five", 6: "six"}
print(t1)
print(t2)
t3 = t1|t2
t3

for t in t3:
  print(t, ":",len(t3[t]))